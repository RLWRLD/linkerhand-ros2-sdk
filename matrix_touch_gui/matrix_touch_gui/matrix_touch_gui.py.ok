#!/usr/bin/env python3
import sys
import json
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                            QHBoxLayout, QLabel, QTextEdit, QPushButton, QComboBox,
                            QSpinBox)
from PyQt5.QtGui import QPainter, QColor, QPen, QFont, QBrush
from PyQt5.QtCore import Qt, QTimer, QObject, pyqtSignal

class DotMatrixWidget(QWidget):
    """点阵显示部件 - 红色渐变版"""
    def __init__(self, rows=12, cols=6, parent=None):
        super().__init__(parent)
        self.rows = rows
        self.cols = cols
        self.dot_size = 8
        self.spacing = 4
        self.data = None
        self.setMinimumSize(
            cols * (self.dot_size + self.spacing) + self.spacing,
            rows * (self.dot_size + self.spacing) + self.spacing
        )
        
    def set_data(self, data):
        """设置点阵数据"""
        self.data = data
        self.update()
        
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        pen = QPen(QColor(0, 0, 0), 1)
        painter.setPen(pen)
        
        default_brush = QBrush(QColor(200, 200, 200))  # 灰色默认点
        
        for row in range(self.rows):
            for col in range(self.cols):
                x = self.spacing + col * (self.dot_size + self.spacing)
                y = self.spacing + row * (self.dot_size + self.spacing)
                
                if self.data and isinstance(self.data, list) and len(self.data) > row * self.cols + col:
                    try:
                        value = self.data[row * self.cols + col]
                        if value > 0:
                            # 红色渐变逻辑：数值越大红色越深
                            alpha = min(255, max(0, int(value)))  # 确保alpha值在0-255范围内
                            red_color = QColor(255, 0, 0)  # 红色
                            red_color.setAlpha(alpha)
                            painter.setBrush(QBrush(red_color))
                        else:
                            painter.setBrush(default_brush)
                    except:
                        painter.setBrush(default_brush)
                else:
                    painter.setBrush(default_brush)
                    
                painter.drawEllipse(x, y, self.dot_size, self.dot_size)

class HandMatrixGui(Node, QObject):
    """带刷新频率控制的手掌矩阵界面"""
    update_signal = pyqtSignal(str)
    
    def __init__(self):
        Node.__init__(self, 'raw_data_gui_node')
        QObject.__init__(self)
        # 声明参数（带默认值）
        self.declare_parameter('hand_type', 'left')
        self.declare_parameter('hand_joint', 'L10')
        # 获取参数值
        self.hand_type = self.get_parameter('hand_type').value
        self.hand_joint = self.get_parameter('hand_joint').value

        # 连接信号槽
        self.update_signal.connect(self.add_message)
        
        # 刷新控制参数
        self.refresh_interval = 200  # 默认刷新间隔200ms
        self.data_cache = {}  # 用于缓存数据
        
        # 创建刷新定时器
        self.refresh_timer = QTimer()
        self.refresh_timer.timeout.connect(self.process_cached_data)
        self.refresh_timer.start(self.refresh_interval)
        
        # 创建应用和窗口
        self.app = QApplication(sys.argv)
        self.window = QMainWindow()
        self.window.setWindowTitle("ROS2手掌点阵界面（红色渐变版）")
        self.window.setGeometry(100, 100, 900, 650)
        
        # 创建中心部件
        central_widget = QWidget()
        self.window.setCentralWidget(central_widget)
        main_layout = QHBoxLayout(central_widget)
        
        # 左侧区域
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        
        # 话题选择
        topic_layout = QHBoxLayout()
        self.topic_combo = QComboBox()
        left_topic = "/cb_right_hand_matrix_touch"
        right_topic = "/cb_left_hand_matrix_touch"
        if self.hand_type == "right":
            self.topic_combo.addItems([left_topic, right_topic])
        else:
            self.topic_combo.addItems([right_topic, left_topic])
        
        self.subscribe_btn = QPushButton("订阅/取消")
        self.subscribe_btn.clicked.connect(self.toggle_subscription)
        
        topic_layout.addWidget(QLabel("话题:"))
        topic_layout.addWidget(self.topic_combo)
        topic_layout.addWidget(self.subscribe_btn)
        left_layout.addLayout(topic_layout)
        
        # 刷新频率控制
        freq_layout = QHBoxLayout()
        freq_layout.addWidget(QLabel("刷新频率(ms):"))
        self.freq_spinbox = QSpinBox()
        self.freq_spinbox.setRange(100, 1000)
        self.freq_spinbox.setValue(self.refresh_interval)
        self.freq_spinbox.valueChanged.connect(self.set_refresh_interval)
        freq_layout.addWidget(self.freq_spinbox)
        freq_layout.addWidget(QLabel("(值越大刷新越慢)"))
        left_layout.addLayout(freq_layout)
        
        # 状态标签
        self.status_label = QLabel("状态: 未订阅 | 红色渐变显示")
        self.status_label.setStyleSheet("color: red; font-weight: bold;")
        left_layout.addWidget(self.status_label)
        
        # 终端显示
        self.terminal = QTextEdit()
        self.terminal.setReadOnly(True)
        self.terminal.setStyleSheet("background-color: black; color: lime; font-family: monospace;")
        left_layout.addWidget(self.terminal)
        
        # 右侧区域
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        
        # 五个手指的点阵
        self.finger_matrices = {}
        finger_names = ["thumb_matrix", "index_matrix", "middle_matrix", "ring_matrix", "little_matrix"]
        display_names = ["拇指", "食指", "中指", "无名指", "小指"]
        
        for finger_name, display_name in zip(finger_names, display_names):
            finger_layout = QVBoxLayout()
            finger_layout.addWidget(QLabel(display_name))
            
            matrix = DotMatrixWidget()
            finger_layout.addWidget(matrix)
            
            right_layout.addLayout(finger_layout)
            self.finger_matrices[finger_name] = matrix
        
        # 添加到主布局
        main_layout.addWidget(left_widget, 2)
        main_layout.addWidget(right_widget, 1)
        
        # 初始化变量
        self.subscription = None
        self.is_subscribed = False
        
        # 显示窗口
        self.window.show()
        self.set_refresh_interval(interval=200)
        
        # 添加初始消息
        self.add_message("红色渐变版界面已启动")
        self.add_message("当前刷新频率: {}ms".format(self.refresh_interval))
        self.add_message("请选择话题并点击'订阅/取消'按钮")
        
    def toggle_subscription(self):
        if self.is_subscribed:
            self.unsubscribe()
        else:
            self.subscribe()
            
    def subscribe(self):
        topic = self.topic_combo.currentText()
        self.add_message(f"正在订阅话题: {topic}")
        
        self.subscription = self.create_subscription(
            String,
            topic,
            self.topic_callback,
            10
        )
        
        self.is_subscribed = True
        self.status_label.setText(f"状态: 已订阅 {topic} | 红色渐变显示")
        self.status_label.setStyleSheet("color: green; font-weight: bold;")
        self.add_message(f"已订阅话题: {topic}")
        
    def unsubscribe(self):
        if self.subscription:
            self.destroy_subscription(self.subscription)
            self.subscription = None
            
        self.is_subscribed = False
        self.status_label.setText("状态: 未订阅 | 红色渐变显示")
        self.status_label.setStyleSheet("color: red; font-weight: bold;")
        self.add_message("已取消订阅")
        
    def topic_callback(self, msg):
        try:
            data = json.loads(msg.data)
            for finger_name, matrix_data in data.items():
                if finger_name in self.finger_matrices:
                    # 缓存数据，由定时器统一更新
                    self.data_cache[finger_name] = matrix_data
                    
        except json.JSONDecodeError as e:
            self.add_message(f"JSON解析错误: {str(e)}")
        except Exception as e:
            self.add_message(f"数据处理错误: {str(e)}")
            
    def process_cached_data(self):
        """定时处理缓存的数据并更新界面"""
        if self.data_cache and self.is_subscribed:
            for finger_name, matrix_data in self.data_cache.items():
                if finger_name in self.finger_matrices:
                    # 更新点阵显示
                    flattened = [item for sublist in matrix_data for item in sublist]
                    self.finger_matrices[finger_name].set_data(flattened)
                    
                    # 更新终端显示
                    display_name = {
                        "thumb_matrix": "拇指", 
                        "index_matrix": "食指", 
                        "middle_matrix": "中指", 
                        "ring_matrix": "无名指", 
                        "little_matrix": "小指"
                    }.get(finger_name, finger_name)
                    
                    self.add_message(f"已更新{display_name}矩阵数据：{matrix_data}")
            
            # 清空缓存
            self.data_cache.clear()
        
    def set_refresh_interval(self, interval=200):
        if interval < 200:
            print("刷新间隔不能低于200ms",flush=True)
            return
        self.refresh_interval = interval
        self.refresh_timer.setInterval(interval)
        self.add_message(f"刷新频率已调整为{interval}ms")
        
    def add_message(self, text):
        import time
        timestamp = time.strftime("%H:%M:%S")
        self.terminal.append(f"[{timestamp}] {text}")
        self.terminal.moveCursor(self.terminal.textCursor().End)
        
    def run(self):
        sys.exit(self.app.exec_())

def main(args=None):
    rclpy.init(args=args)
    try:
        gui_node = HandMatrixGui()
        
        # 在单独线程中运行ROS2 spin
        import threading
        spin_thread = threading.Thread(target=rclpy.spin, args=(gui_node,), daemon=True)
        spin_thread.start()
        
        gui_node.run()
        rclpy.shutdown()
        spin_thread.join()
        
    except Exception as e:
        print(f"应用启动失败: {str(e)}")
        rclpy.shutdown()

if __name__ == "__main__":
    main()